<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Phone Camera Web App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- Bootstrap CSS for layout -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Font Awesome for icons -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet">
  <style>
    :root {
      --safe-area-inset-top: env(safe-area-inset-top, 0px);
      --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
      --safe-area-inset-left: env(safe-area-inset-left, 0px);
      --safe-area-inset-right: env(safe-area-inset-right, 0px);
    }
    
    * {
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    body {
      background: #000;
      color: #fff;
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Arial, sans-serif;
      overflow-x: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
    }
    
    .landscape-mode .rotate-item {
      transition: transform 0.3s ease;
    }
    
    /* Ensure smooth transitions for orientation changes */
    .camera-app, .viewfinder-container, .top-bar, .bottom-bar, .controls-bar {
      transition: all 0.3s ease;
    }
    
    /* Ensure viewfinder text is not rotated in landscape mode */
    body.landscape-mode .viewfinder-text {
      transform: translateX(-50%);
      rotate: none;
    }

    .camera-app {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: #000;
      position: relative;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: calc(16px + var(--safe-area-inset-top)) 16px 16px;
      background: #000;
      font-size: clamp(1.2rem, 4vw, 1.5rem);
      position: relative;
      z-index: 10;
      gap: 8px;
    }

    .top-bar i {
      margin: 0;
      color: #fff;
      font-size: clamp(1.2rem, 4vw, 1.5rem);
      padding: 8px;
    }

    .viewfinder-container {
      flex: 1;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      min-height: 0;
      overflow: hidden;
    }
    
    /* Landscape orientation handling */
    @media (orientation: landscape) {
      body {
        /* Add landscape mode class to body for global styles */
        --rotation-angle: 0deg;
      }
      
      /* Transform camera app layout in landscape mode */
      body.landscape-mode .camera-app {
        flex-direction: row;
      }
      
      /* Move top bar to the left side */
      body.landscape-mode .top-bar {
        flex-direction: column;
        width: 60px;
        height: 100%;
        padding: calc(16px + var(--safe-area-inset-top)) 8px 8px calc(8px + var(--safe-area-inset-left));
        position: absolute;
        left: 0;
        top: 0;
        z-index: 20;
      }
      
      /* Move bottom bar to the right side */
      body.landscape-mode .bottom-bar {
        flex-direction: column;
        width: 80px;
        height: 100%;
        position: absolute;
        right: 0;
        top: 0;
        padding: calc(16px + var(--safe-area-inset-top)) calc(8px + var(--safe-area-inset-right)) 8px 8px;
        z-index: 20;
      }
      
      /* Adjust viewfinder container to take full space */
      body.landscape-mode .viewfinder-container {
        width: 100%;
        height: 100%;
        margin: 0;
      }
      
      /* Keep viewfinder text positioned correctly in landscape */
      body.landscape-mode .viewfinder-text {
        bottom: 20%;
        left: 50%;
        transform: translateX(-50%);
      }
      
      /* Mode switcher in landscape */
      body.landscape-mode .mode-switcher {
        flex-direction: column;
        height: auto;
        gap: 12px;
        width: auto;
        padding-right: 4px;
      }
      
      /* Bottom controls in landscape */
      body.landscape-mode .bottom-controls {
        flex-direction: column;
        height: auto;
        gap: 16px;
        margin-top: auto;
        margin-bottom: 24px;
      }
      
      /* Controls bar in landscape */
      body.landscape-mode .controls-bar {
        position: absolute;
        top: 0;
        right: 80px;
        width: auto;
        height: 100%;
        padding: calc(16px + var(--safe-area-inset-top)) 4px 16px 0;
        z-index: 15;
      }
      
      /* Zoom bar in landscape */
      body.landscape-mode .zoom-bar {
        flex-direction: column;
        width: auto;
        height: auto;
        padding: 0 4px;
      }
      
      /* Side buttons in landscape */
      body.landscape-mode .side-btns {
        right: 100px;
        bottom: 16px;
      }
      
      /* Thumbnail in landscape */
      body.landscape-mode .thumb {
        order: 3;
      }
      
      /* Shutter button in landscape */
      body.landscape-mode .shutter-btn {
        order: 1;
        margin-bottom: 16px;
      }
      
      /* Switch camera button in landscape */
      body.landscape-mode .switch-cam-btn {
        order: 2;
        margin-bottom: 16px;
      }
      
      /* Timer button in landscape */
      body.landscape-mode .timer-btn {
        margin-right: 0;
        margin-bottom: 8px;
      }
      
      /* Adjustments for smaller screens in landscape */
      @media (max-height: 450px) {
        body.landscape-mode .top-bar {
          width: 50px;
        }
        
        body.landscape-mode .bottom-bar {
          width: 70px;
        }
        
        body.landscape-mode .shutter-btn {
          width: clamp(50px, 15vw, 60px);
          height: clamp(50px, 15vw, 60px);
        }
        
        body.landscape-mode .thumb {
          width: clamp(40px, 12vw, 48px);
          height: clamp(40px, 12vw, 48px);
        }
        
        body.landscape-mode .switch-cam-btn {
          width: clamp(36px, 10vw, 40px);
          height: clamp(36px, 10vw, 40px);
        }
        
        body.landscape-mode .controls-bar {
          right: 70px;
        }
        
        body.landscape-mode .side-btns {
          right: 85px;
        }
      }
    }

    .viewfinder-text {
      position: absolute;
      bottom: 20%;
      left: 50%;
      transform: translateX(-50%);
      font-size: clamp(2rem, 8vw, 3rem);
      color: red;
      font-weight: 500;
      pointer-events: none;
      user-select: none;
      z-index: 2;
    }

    video#viewfinder {
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #000;
      transform-origin: center center;
      transition: transform 0.2s ease-out;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .controls-bar {
      background: #000;
      padding: 16px 0 0 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      min-height: 80px;
      position: relative;
      z-index: 10;
    }

    .zoom-bar {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
      flex-wrap: wrap;
      gap: 8px;
      width: 100%;
      padding: 0 16px;
      min-height: 40px;
      position: relative;
    }

    .zoom-bar span {
      color: #fff;
      margin: 0;
      font-size: clamp(0.9rem, 3vw, 1.1rem);
      cursor: pointer;
      padding: 4px 12px;
      border-radius: 8px;
      white-space: nowrap;
      transition: all 0.2s ease;
      min-width: 48px;
      text-align: center;
      position: relative;
      z-index: 1;
    }

    .zoom-bar span:hover {
      background: #333;
    }

    .zoom-bar .active {
      background: #444;
      color: orange;
    }

    .zoom-bar .disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .timer-btn {
      background: orange;
      color: #000;
      border-radius: 16px;
      padding: 4px 12px;
      margin-right: 12px;
      font-weight: 600;
      font-size: clamp(0.9rem, 3vw, 1.1rem);
      border: none;
    }

    .side-btns {
      position: absolute;
      right: 16px;
      bottom: 80px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      z-index: 10;
    }

    .side-btns button {
      background: #222;
      border: none;
      border-radius: 50%;
      width: clamp(40px, 12vw, 44px);
      height: clamp(40px, 12vw, 44px);
      color: #fff;
      font-size: clamp(1.1rem, 3.5vw, 1.3rem);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #night-mode-btn.active {
      background: linear-gradient(135deg, #333, #0072ff);
      color: yellow;
    }
    
    #night-mode-btn.active i {
      filter: drop-shadow(0 0 3px rgba(255, 255, 0, 0.7));
    }
    
    .night-mode-indicator {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      color: yellow;
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 0.9rem;
      display: none;
      z-index: 5;
      pointer-events: none;
    }
    
    .night-mode-indicator.active {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .bottom-bar {
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px 16px calc(16px + var(--safe-area-inset-bottom));
      position: relative;
      z-index: 10;
      gap: 16px;
    }

    .mode-switcher {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: clamp(0.9rem, 3vw, 1.1rem);
      color: #fff;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      -ms-overflow-style: none;
      padding-bottom: 4px;
      width: 100%;
    }

    .mode-switcher::-webkit-scrollbar {
      display: none;
    }

    .mode-switcher span {
      white-space: nowrap;
    }

    .mode-switcher .active {
      color: orange;
      font-weight: 600;
    }

    .bottom-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      width: 100%;
    }

    .thumb {
      width: clamp(48px, 14vw, 56px);
      height: clamp(48px, 14vw, 56px);
      border-radius: 12px;
      object-fit: cover;
      border: 2px solid #fff;
      background: #222;
      flex-shrink: 0;
      order: 1;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .thumb:hover {
      transform: scale(1.05);
    }

    .shutter-btn {
      background: linear-gradient(180deg, #ff9800 0%, #ff5722 100%);
      border: 4px solid #fff;
      border-radius: 50%;
      width: clamp(60px, 18vw, 72px);
      height: clamp(60px, 18vw, 72px);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 0 2px #000;
      cursor: pointer;
      transition: box-shadow 0.2s;
      flex-shrink: 0;
      order: 2;
    }

    .shutter-btn:active {
      box-shadow: 0 0 0 6px #ff9800;
    }

    .switch-cam-btn {
      background: #222;
      border: none;
      border-radius: 50%;
      width: clamp(40px, 12vw, 44px);
      height: clamp(40px, 12vw, 44px);
      color: #fff;
      font-size: clamp(1.1rem, 3.5vw, 1.3rem);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      order: 3;
    }
    
    #night-mode-btn.active {
      background: linear-gradient(135deg, #333, #0072ff);
      color: yellow;
    }
    
    #night-mode-btn.active i {
      filter: drop-shadow(0 0 3px rgba(255, 255, 0, 0.7));
    }
    
    .night-mode-indicator {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      color: yellow;
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 0.9rem;
      display: none;
      z-index: 5;
      pointer-events: none;
    }
    
    .night-mode-indicator.active {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    #flash-btn.active {
      background: linear-gradient(135deg, #333, #ff7700);
      color: #ffcc00;
    }
    
    #flash-btn.active i {
      filter: drop-shadow(0 0 3px rgba(255, 204, 0, 0.7));
    }

    @media (max-width: 360px) {
      .top-bar {
        padding: calc(12px + var(--safe-area-inset-top)) 12px 12px;
      }
      
      .top-bar i {
        padding: 6px;
      }
      
      .bottom-bar {
        padding: 8px 12px calc(16px + var(--safe-area-inset-bottom));
        gap: 12px;
      }
      
      .mode-switcher {
        gap: 6px;
      }
      
      .bottom-controls {
        gap: 12px;
      }

      .controls-bar {
        padding: 12px 0 0 0;
        gap: 12px;
      }

      .zoom-bar {
        gap: 6px;
        padding: 0 12px;
      }

      .zoom-bar span {
        padding: 3px 10px;
      }
    }

    @media (max-height: 600px) {
      .viewfinder-text {
        bottom: 15%;
        font-size: clamp(1.8rem, 6vw, 2.5rem);
      }
      
      .side-btns {
        bottom: 60px;
        gap: 12px;
      }
    }

    /* Recents Modal Styles */
    .recents-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #000;
      z-index: 1000;
      display: none;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .recents-modal.active {
      display: flex;
      opacity: 1;
    }

    .recents-top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: calc(16px + var(--safe-area-inset-top)) 16px 16px;
      background: #000;
      position: relative;
      z-index: 10;
    }

    .back-btn {
      background: #222;
      border: none;
      border-radius: 50%;
      width: clamp(40px, 12vw, 44px);
      height: clamp(40px, 12vw, 44px);
      color: #fff;
      font-size: clamp(1.1rem, 3.5vw, 1.3rem);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .back-btn:hover {
      background: #333;
    }

    .recents-title {
      color: #fff;
      font-size: clamp(1.1rem, 3.5vw, 1.3rem);
      font-weight: 500;
    }

    .recents-grid {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px;
      padding: 16px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .recent-photo {
      aspect-ratio: 1/1;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      cursor: pointer;
    }

    .recent-photo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .recent-photo.selected {
      border: 2px solid orange;
    }

    .recents-bottom-bar {
      background: #000;
      padding: 16px;
      display: flex;
      justify-content: center;
      gap: 16px;
      border-top: 1px solid #222;
    }

    .save-btn {
      background: orange;
      color: #000;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .save-btn:hover {
      background: #ffb74d;
    }

    .save-btn:disabled {
      background: #666;
      cursor: not-allowed;
    }

    /* Full-screen photo view */
    .photo-view {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #000;
      z-index: 2000;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .photo-view.active {
      display: flex;
      opacity: 1;
    }

    .photo-view-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .photo-view-top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: calc(16px + var(--safe-area-inset-top)) 16px 16px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
    }

    .photo-view-bottom-bar {
      background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
      padding: 16px;
      display: flex;
      justify-content: center;
      gap: 16px;
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 10;
    }

    .photo-view-img {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .photo-view-img img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    @media (max-width: 360px) {
      .recents-grid {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 6px;
        padding: 12px;
      }

      .photo-view-top-bar,
      .photo-view-bottom-bar {
        padding: 12px;
      }
    }

    .settings-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.95);
      z-index: 3000;
      display: none;
      align-items: flex-start;
      justify-content: center;
      transition: opacity 0.3s;
    }
    .settings-modal.active {
      display: flex;
      opacity: 1;
    }
    .settings-content {
      width: 100%;
      max-width: 480px;
      border-radius: 0 0 24px 24px;
      background: #181818;
      padding: 32px 0 16px 0;
      box-shadow: 0 -2px 24px rgba(0,0,0,0.4);
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 24px;
      align-items: center;
    }
    .settings-close {
      position: absolute;
      top: 16px;
      right: 24px;
      background: none;
      border: none;
      color: #fff;
      font-size: 2rem;
      z-index: 10;
      cursor: pointer;
    }
    .settings-section {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    .settings-row {
      display: flex;
      gap: 16px;
      justify-content: center;
      width: 100%;
    }
    .settings-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.3rem;
      padding: 8px 20px;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    .settings-btn.active, .settings-btn:focus {
      background: #222;
      color: orange;
      font-weight: 600;
    }
    .settings-icons {
      margin-top: 16px;
      gap: 12px;
      display: flex;
      flex-direction: row;
      justify-content: center;
      width: 100%;
    }
    .settings-icon-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: none;
      border: none;
      color: #fff;
      font-size: 1.2rem;
      gap: 4px;
      padding: 8px 12px;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      min-width: 90px;
    }
    .settings-icon-btn.active {
      background: orange;
      color: #181818;
      font-weight: 600;
    }
    .settings-icon-btn span {
      font-size: 0.95rem;
      margin-top: 2px;
    }
    .device-settings-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.97);
      z-index: 4000;
      display: none;
      align-items: flex-start;
      justify-content: center;
      transition: opacity 0.3s;
    }
    .device-settings-modal.active {
      display: flex;
      opacity: 1;
    }
    .device-settings-content {
      width: 100%;
      max-width: 480px;
      border-radius: 0 0 24px 24px;
      background: #181818;
      padding: 32px 0 16px 0;
      box-shadow: 0 -2px 24px rgba(0,0,0,0.4);
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      min-height: 320px;
      max-height: 80vh;
      overflow-y: auto;
    }
    #device-settings-list {
      width: 90%;
      max-width: 420px;
      margin: 0 auto;
      color: #fff;
      font-size: 1rem;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .device-settings-item {
      background: #232323;
      border-radius: 12px;
      padding: 12px 16px;
      margin-bottom: 4px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .device-settings-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 4px;
    }
    .device-settings-row label {
      min-width: 80px;
      color: #bbb;
      font-size: 0.98rem;
    }
    .device-settings-row input[type="text"] {
      flex: 1;
      background: #181818;
      color: #fff;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 1rem;
    }
    .device-settings-row select, .device-settings-row input[type="checkbox"] {
      font-size: 1rem;
      background: #181818;
      color: #fff;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 4px 8px;
    }
    .device-settings-row input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: orange;
    }
    video#viewfinder.mirrored {
      transform: translate(-50%, -50%) scaleX(-1) !important;
    }

    /* Landscape orientation handling */
    @media (orientation: landscape) {
      body {
        /* Add landscape mode class to body for global styles */
        --rotation-angle: 0deg;
      }
      
      body.landscape-mode .camera-app {
        /* Keep the app layout the same in landscape */
        flex-direction: column;
      }
      
      /* Rotation for top bar elements */
      body.landscape-mode .top-bar {
        padding: calc(16px + var(--safe-area-inset-right)) 16px 16px calc(16px + var(--safe-area-inset-left));
      }
      
      body.landscape-mode .top-bar i.rotate-item {
        transform: rotate(var(--rotation-angle));
      }
      
      /* Bottom bar and controls in landscape */
      body.landscape-mode .bottom-bar {
        padding: 8px 16px calc(16px + var(--safe-area-inset-left)) calc(16px + var(--safe-area-inset-right));
      }
      
      body.landscape-mode .mode-switcher span.rotate-item {
        transform: rotate(var(--rotation-angle));
      }
      
      /* Side buttons rotation */
      body.landscape-mode .side-btns {
        /* Adjusted position for landscape */
        right: 16px;
        bottom: 80px;
      }
      
      body.landscape-mode .side-btns button i.rotate-item {
        transform: rotate(var(--rotation-angle));
      }
      
      /* Control buttons rotation */
      body.landscape-mode .switch-cam-btn i.rotate-item,
      body.landscape-mode .zoom-bar span.rotate-item {
        transform: rotate(var(--rotation-angle));
      }
      
      /* Timer button rotation */
      body.landscape-mode .timer-btn.rotate-item {
        transform: rotate(var(--rotation-angle));
      }
    }
  </style>
</head>
<body>
  <div class="camera-app">
    <!-- Top Bar -->
    <div class="top-bar">
      <i class="fas fa-volume-mute"></i>
      <i class="fas fa-square-root-alt"></i>
      <i class="fas fa-eye-slash"></i>
      <i class="fas fa-running"></i>
      <i class="fas fa-crosshairs"></i>
      <i class="fas fa-bars"></i>
    </div>
    <!-- Viewfinder -->
    <div class="viewfinder-container position-relative">
      <video id="viewfinder" autoplay playsinline></video>
      <div class="viewfinder-text">Viewfinder</div>
      <div class="night-mode-indicator">
        <i class="fas fa-moon"></i> Night Mode
      </div>
      <div class="side-btns">
        <button id="flash-btn" title="Toggle Flash">
          <i class="fas fa-bolt"></i>
        </button>
        <button id="night-mode-btn" title="Night Mode">
          <i class="fas fa-moon"></i>
        </button>
        <button id="filter-btn" title="Filters">
          <i class="fas fa-magic"></i>
        </button>
      </div>
    </div>
    <!-- Controls Bar -->
    <div class="controls-bar">
      <div class="d-flex align-items-center">
        <button class="timer-btn" id="timer-btn">1s</button>
        <div class="zoom-bar" id="zoom-bar">
          <span data-zoom="0.6">0.6</span>
          <span data-zoom="1.2">1.2</span>
          <span data-zoom="2">2</span>
          <span data-zoom="3">3</span>
          <span data-zoom="6" class="active">6x</span>
        </div>
      </div>
    </div>
    <!-- Bottom Bar -->
    <div class="bottom-bar">
      <div class="mode-switcher">
        <span>MASTER</span>
        <span>VIDEO</span>
        <span class="active">PHOTO</span>
        <span>PORTRAIT</span>
        <span>MORE</span>
      </div>
      <div class="bottom-controls">
        <img id="thumb" class="thumb" src="https://via.placeholder.com/56x56.png?text=+" alt="Thumbnail">
        <button class="shutter-btn" id="shutter-btn"></button>
        <button class="switch-cam-btn" id="switch-cam-btn" title="Switch Camera"><i class="fas fa-sync-alt"></i></button>
      </div>
    </div>
  </div>

  <!-- Recents Modal -->
  <div class="recents-modal" id="recents-modal">
    <div class="recents-top-bar">
      <button class="back-btn" id="back-btn" title="Back to Camera">
        <i class="fas fa-arrow-left"></i>
      </button>
      <div class="recents-title">Recent Photos</div>
      <div style="width: 44px"></div>
    </div>
    <div class="recents-grid" id="recents-grid">
      <!-- Photos will be added here dynamically -->
    </div>
    <div class="recents-bottom-bar">
      <button class="save-btn" id="save-btn" disabled>Save Selected</button>
    </div>
  </div>

  <!-- Full-screen Photo View -->
  <div class="photo-view" id="photo-view">
    <div class="photo-view-content">
      <div class="photo-view-top-bar">
        <button class="back-btn" id="photo-view-back-btn" title="Back to Gallery">
          <i class="fas fa-arrow-left"></i>
        </button>
        <div style="width: 44px"></div>
      </div>
      <div class="photo-view-img">
        <img id="photo-view-img" src="" alt="Full size photo">
      </div>
      <div class="photo-view-bottom-bar">
        <button class="save-btn" id="photo-view-save-btn">Save Photo</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="settings-modal" id="settings-modal">
    <div class="settings-content">
      <button class="settings-close" id="settings-close" title="Close"><i class="fas fa-times"></i></button>
      <div class="settings-section">
        <div class="settings-row" id="aspect-ratio-row">
          <button class="settings-btn" data-aspect="1:1">1:1</button>
          <button class="settings-btn" data-aspect="3:4">3:4</button>
          <button class="settings-btn" data-aspect="9:16">9:16</button>
          <button class="settings-btn" data-aspect="full">Full</button>
        </div>
      </div>
      <div class="settings-section">
        <div class="settings-row" id="timer-row">
          <button class="settings-btn" data-timer="off">Timer: Off</button>
          <button class="settings-btn" data-timer="3">3 s</button>
          <button class="settings-btn" data-timer="10">10 s</button>
        </div>
      </div>
      <div class="settings-section settings-row settings-icons">
        <button class="settings-icon-btn active"><i class="fas fa-sun"></i><span>Auto HDR</span></button>
        <button class="settings-icon-btn"><i class="fas fa-layer-group"></i><span>Interval shoot</span></button>
        <button class="settings-icon-btn"><i class="fas fa-cog"></i><span>Settings</span></button>
      </div>
    </div>
  </div>

  <!-- Device Camera Settings Modal -->
  <div class="device-settings-modal" id="device-settings-modal">
    <div class="device-settings-content">
      <button class="settings-close" id="device-settings-close" title="Close"><i class="fas fa-times"></i></button>
      <h4 style="color:#fff;text-align:center;margin-bottom:16px;">Device Camera Settings</h4>
      <div id="device-settings-list"></div>
      <div style="display:flex;justify-content:center;margin-top:16px;">
        <button class="save-btn" id="device-settings-save">Save</button>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS (for layout, not required for core logic) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <!-- Main Camera Logic -->
  <script>
    let currentStream = null;
    let currentDeviceId = null;
    let devices = [];
    let facingMode = "environment";
    let photoBlob = null;
    let timer = 1;
    let currentZoom = 1;
    let maxZoom = 1;
    let minZoom = 1;
    let zoomStep = 0.5;
    let isDigitalZoom = false;
    let recentPhotos = [];
    let selectedPhoto = null;
    let aspectRatio = '3:4';
    let timerSetting = 'off';
    let isHDR = false;
    let hdrExposures = [-2, 0, 2]; // EV values for HDR capture
    let isProcessingHDR = false;
    let isLandscape = false; // Track device orientation
    let isNightMode = false; // Track night mode state

    // Get all video input devices
    async function getCameras() {
      const allDevices = await navigator.mediaDevices.enumerateDevices();
      devices = allDevices.filter(device => device.kind === 'videoinput');
    }

    // Start camera with given deviceId or facingMode
    async function startCamera(deviceId = null, facing = "environment") {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
      let constraints = {
        video: {
          facingMode: deviceId ? undefined : { exact: facing },
          deviceId: deviceId ? { exact: deviceId } : undefined,
          width: { ideal: 4096 },
          height: { ideal: 2160 }
        },
        audio: false
      };
      try {
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        document.getElementById('viewfinder').srcObject = currentStream;
        
        // Get zoom capabilities and max resolution
        const videoTrack = currentStream.getVideoTracks()[0];
        const capabilities = videoTrack.getCapabilities();
        const supportedFeatures = [];
        
        // Check for optical zoom support
        if (capabilities.zoom) {
          isDigitalZoom = false;
          minZoom = capabilities.zoom.min;
          maxZoom = capabilities.zoom.max;
          zoomStep = (maxZoom - minZoom) / 10;
        } else {
          isDigitalZoom = true;
          minZoom = 1;
          maxZoom = 6;
          zoomStep = 0.5;
        }
        
        // Update zoom UI based on available zoom type
        updateZoomUI();
        
        // Try to get the actual max resolution
        if (capabilities.width && capabilities.height) {
          const maxWidth = capabilities.width.max;
          const maxHeight = capabilities.height.max;
          const settings = videoTrack.getSettings();
          if ((settings.width !== maxWidth || settings.height !== maxHeight) && maxWidth && maxHeight) {
            currentStream.getTracks().forEach(track => track.stop());
            currentStream = await navigator.mediaDevices.getUserMedia({
              video: {
                facingMode: deviceId ? undefined : { exact: facing },
                deviceId: deviceId ? { exact: deviceId } : undefined,
                width: { exact: maxWidth },
                height: { exact: maxHeight }
              },
              audio: false
            });
            document.getElementById('viewfinder').srcObject = currentStream;
          }
          showResolution(maxWidth, maxHeight);
        } else {
          const settings = videoTrack.getSettings();
          showResolution(settings.width, settings.height);
        }
        
        // Try to set best available camera features
        if (capabilities.focusMode && capabilities.focusMode.length) {
          supportedFeatures.push('Focus: ' + capabilities.focusMode.join('/'));
          if (capabilities.focusMode.includes('continuous')) {
            await videoTrack.applyConstraints({advanced: [{focusMode: 'continuous'}]});
          } else if (capabilities.focusMode.includes('auto')) {
            await videoTrack.applyConstraints({advanced: [{focusMode: 'auto'}]});
          }
        }
        if (capabilities.exposureMode && capabilities.exposureMode.length) {
          supportedFeatures.push('Exposure: ' + capabilities.exposureMode.join('/'));
          if (capabilities.exposureMode.includes('continuous')) {
            await videoTrack.applyConstraints({advanced: [{exposureMode: 'continuous'}]});
          } else if (capabilities.exposureMode.includes('auto')) {
            await videoTrack.applyConstraints({advanced: [{exposureMode: 'auto'}]});
          }
        }
        if (capabilities.whiteBalanceMode && capabilities.whiteBalanceMode.length) {
          supportedFeatures.push('WB: ' + capabilities.whiteBalanceMode.join('/'));
          if (capabilities.whiteBalanceMode.includes('continuous')) {
            await videoTrack.applyConstraints({advanced: [{whiteBalanceMode: 'continuous'}]});
          } else if (capabilities.whiteBalanceMode.includes('auto')) {
            await videoTrack.applyConstraints({advanced: [{whiteBalanceMode: 'auto'}]});
          }
        }
        if (capabilities.torch) {
          supportedFeatures.push('Torch');
        }
        
        // Show supported features in the UI
        showSupportedFeatures(supportedFeatures);
        
        // Apply current aspect ratio to viewfinder
        updateAspectRatio();
        
      } catch (e) {
        if (deviceId) {
          constraints.video = { deviceId: { exact: deviceId } };
        } else {
          constraints.video = true;
        }
        try {
          currentStream = await navigator.mediaDevices.getUserMedia(constraints);
          document.getElementById('viewfinder').srcObject = currentStream;
          const videoTrack = currentStream.getVideoTracks()[0];
          const capabilities = videoTrack.getCapabilities();
          const settings = videoTrack.getSettings();
          showResolution(settings.width, settings.height);
          showSupportedFeatures([]);
          
          // Check for optical zoom support
          if (capabilities.zoom) {
            isDigitalZoom = false;
            minZoom = capabilities.zoom.min;
            maxZoom = capabilities.zoom.max;
            zoomStep = (maxZoom - minZoom) / 10;
          } else {
            isDigitalZoom = true;
            minZoom = 1;
            maxZoom = 6;
            zoomStep = 0.5;
          }
          
          // Update zoom UI based on available zoom type
          updateZoomUI();
          
          // Apply current aspect ratio to viewfinder
          updateAspectRatio();
        } catch (err) {
          alert('Camera access denied or not available.');
        }
      }
    }

    // Update zoom UI based on device capabilities
    function updateZoomUI() {
      const zoomBar = document.getElementById('zoom-bar');
      
      // Create zoom options based on available zoom type
      const zoomValues = [];
      if (!isDigitalZoom) {
        // Optical zoom options
        for (let zoom = minZoom; zoom <= maxZoom; zoom += zoomStep) {
          zoomValues.push(Number(zoom.toFixed(1)));
        }
      } else {
        // Digital zoom options
        zoomValues.push(1, 2, 3, 4, 6);
      }
      
      // Create all spans first
      const spans = zoomValues.map(zoom => {
        const span = document.createElement('span');
        span.textContent = zoom === 1 ? '1x' : zoom + 'x';
        span.dataset.zoom = zoom;
        if (Math.abs(zoom - 1) < 0.1) { // Always set 1x as active by default
          span.classList.add('active');
        }
        if (zoom > maxZoom) {
          span.classList.add('disabled');
        }
        return span;
      });
      
      // Clear and append all at once
      zoomBar.innerHTML = '';
      spans.forEach(span => zoomBar.appendChild(span));
      
      // Reset zoom to 1x
      currentZoom = 1;
      updateViewfinderTransform();
    }

    // Helper to update viewfinder transform (centering, zoom, mirroring)
    function updateViewfinderTransform() {
      const video = document.getElementById('viewfinder');
      let scale = currentZoom || 1;
      let mirrored = false;
      cameraSettings = JSON.parse(localStorage.getItem('cameraSettings') || '{}');
      if (cameraSettings[currentDeviceId] && cameraSettings[currentDeviceId].mirrored) mirrored = true;
      
      // Get current transform properties
      let transform = 'translate(-50%, -50%)';
      
      // Add scale
      if (scale !== 1) {
        transform += ` scale(${scale})`;
      }
      
      // Add mirroring if needed
      if (mirrored) {
        transform += ' scaleX(-1)';
      }
      
      // Apply the transform
      video.style.transform = transform;
    }

    // Apply zoom
    async function applyZoom(zoom) {
      if (zoom < minZoom || zoom > maxZoom) return;
      
      const videoTrack = currentStream.getVideoTracks()[0];
      if (!isDigitalZoom && videoTrack.getCapabilities().zoom) {
        try {
          await videoTrack.applyConstraints({
            advanced: [{ zoom: zoom }]
          });
          currentZoom = zoom;
        } catch (err) {
          console.warn('Failed to apply optical zoom:', err);
          currentZoom = 1; // Reset to 1x on error
        }
      } else if (isDigitalZoom) {
        // Only apply digital zoom if optical zoom is not available
        currentZoom = zoom;
      }
      
      // Update UI without causing layout shifts
      requestAnimationFrame(() => {
        document.querySelectorAll('#zoom-bar span').forEach(span => {
          const spanZoom = parseFloat(span.dataset.zoom);
          span.classList.remove('active');
          if (Math.abs(spanZoom - zoom) < 0.1) {
            span.classList.add('active');
          }
        });
        updateViewfinderTransform();
      });
    }

    // Zoom bar click handler
    document.getElementById('zoom-bar').addEventListener('click', async (e) => {
      if (e.target.dataset.zoom && !e.target.classList.contains('disabled')) {
        const zoom = parseFloat(e.target.dataset.zoom);
        await applyZoom(zoom);
      }
    });

    // Add pinch-to-zoom support
    let initialPinchDistance = 0;
    let initialZoom = 1;
    let isPinching = false;
    let lastZoom = 1;

    document.getElementById('viewfinder').addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        isPinching = true;
        initialPinchDistance = Math.hypot(
          e.touches[0].pageX - e.touches[1].pageX,
          e.touches[0].pageY - e.touches[1].pageY
        );
        initialZoom = currentZoom;
        lastZoom = currentZoom;
      }
    });

    document.getElementById('viewfinder').addEventListener('touchmove', (e) => {
      if (e.touches.length === 2 && isPinching) {
        e.preventDefault();
        const currentDistance = Math.hypot(
          e.touches[0].pageX - e.touches[1].pageX,
          e.touches[0].pageY - e.touches[1].pageY
        );
        const scale = currentDistance / initialPinchDistance;
        const newZoom = Math.min(Math.max(initialZoom * scale, minZoom), maxZoom);
        
        // Only update if the zoom has changed significantly
        if (Math.abs(newZoom - lastZoom) > 0.1) {
          applyZoom(newZoom);
          lastZoom = newZoom;
        }
      }
    });

    document.getElementById('viewfinder').addEventListener('touchend', () => {
      isPinching = false;
    });

    // Switch between cameras
    async function switchCamera() {
      await getCameras();
      if (devices.length < 2) return;
      let idx = devices.findIndex(d => d.deviceId === currentDeviceId);
      idx = (idx + 1) % devices.length;
      currentDeviceId = devices[idx].deviceId;
      await startCamera(currentDeviceId);
      // The startCamera function already calls updateAspectRatio, which includes updateViewfinderTransform
    }

    // HDR processing function
    async function processHDR(video, videoTrack) {
      try {
        // Check if camera supports exposure compensation
        const capabilities = videoTrack.getCapabilities();
        const settings = videoTrack.getSettings();
        
        // If no exposure compensation support, use enhanced single frame
        if (!capabilities.exposureCompensation) {
          console.log('Using enhanced single frame processing');
          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0);
          
          // Get image data
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const outputData = ctx.createImageData(canvas.width, canvas.height);
          
          // Apply local contrast enhancement
          const radius = 2;
          const strength = 0.5;
          
          for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
              const i = (y * canvas.width + x) * 4;
              
              // Calculate local average
              let sumR = 0, sumG = 0, sumB = 0;
              let count = 0;
              
              for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                  const nx = x + dx;
                  const ny = y + dy;
                  
                  if (nx >= 0 && nx < canvas.width && ny >= 0 && ny < canvas.height) {
                    const ni = (ny * canvas.width + nx) * 4;
                    sumR += imageData.data[ni];
                    sumG += imageData.data[ni + 1];
                    sumB += imageData.data[ni + 2];
                    count++;
                  }
                }
              }
              
              const avgR = sumR / count;
              const avgG = sumG / count;
              const avgB = sumB / count;
              
              // Enhance contrast
              outputData.data[i] = Math.min(255, Math.max(0, 
                imageData.data[i] + (imageData.data[i] - avgR) * strength));
              outputData.data[i + 1] = Math.min(255, Math.max(0, 
                imageData.data[i + 1] + (imageData.data[i + 1] - avgG) * strength));
              outputData.data[i + 2] = Math.min(255, Math.max(0, 
                imageData.data[i + 2] + (imageData.data[i + 2] - avgB) * strength));
              outputData.data[i + 3] = 255;
            }
          }
          
          ctx.putImageData(outputData, 0, 0);
          
          return new Promise(resolve => {
            canvas.toBlob(blob => {
              resolve(blob);
            }, 'image/jpeg', 0.95);
          });
        }
        
        // Get supported exposure range
        const minEV = capabilities.exposureCompensation.min;
        const maxEV = capabilities.exposureCompensation.max;
        const step = capabilities.exposureCompensation.step;
        
        // Use fewer exposures but with better timing
        const evValues = [
          Math.max(minEV, -1 * step), // Slightly underexposed
          0,                          // Normal exposure
          Math.min(maxEV, 1 * step)   // Slightly overexposed
        ];
        
        const exposures = [];
        const originalEV = settings.exposureCompensation || 0;
        
        // Quick capture of exposures
        for (const ev of evValues) {
          try {
            await videoTrack.applyConstraints({
              advanced: [{ exposureCompensation: ev }]
            });
            // Shorter wait time
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            exposures.push({ canvas, ev });
          } catch (err) {
            console.warn('Failed to set exposure:', err);
          }
        }
        
        // Reset exposure
        try {
          await videoTrack.applyConstraints({
            advanced: [{ exposureCompensation: originalEV }]
          });
        } catch (err) {
          console.warn('Failed to reset exposure:', err);
        }
        
        // Process HDR
        const outputCanvas = document.createElement('canvas');
        const ctx = outputCanvas.getContext('2d');
        outputCanvas.width = video.videoWidth;
        outputCanvas.height = video.videoHeight;
        
        // Get image data from each exposure
        const imageDatas = exposures.map(({ canvas, ev }) => {
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = canvas.width;
          tempCanvas.height = canvas.height;
          tempCtx.drawImage(canvas, 0, 0);
          return { data: tempCtx.getImageData(0, 0, canvas.width, canvas.height), ev };
        });
        
        // Create output image data
        const outputData = ctx.createImageData(outputCanvas.width, outputCanvas.height);
        
        // Process each pixel
        for (let i = 0; i < outputData.data.length; i += 4) {
          let r = 0, g = 0, b = 0;
          let weight = 0;
          
          // Combine exposures using weighted average
          imageDatas.forEach(({ data, ev }) => {
            const w = Math.pow(2, ev / step); // Weight based on EV
            r += data.data[i] * w;
            g += data.data[i + 1] * w;
            b += data.data[i + 2] * w;
            weight += w;
          });
          
          // Normalize and apply tone mapping
          outputData.data[i] = Math.min(255, Math.max(0, r / weight));
          outputData.data[i + 1] = Math.min(255, Math.max(0, g / weight));
          outputData.data[i + 2] = Math.min(255, Math.max(0, b / weight));
          outputData.data[i + 3] = 255;
        }
        
        // Put the processed image data back
        ctx.putImageData(outputData, 0, 0);
        
        return new Promise(resolve => {
          outputCanvas.toBlob(blob => {
            resolve(blob);
          }, 'image/jpeg', 0.95);
        });
      } catch (err) {
        console.error('HDR processing failed:', err);
        throw err;
      }
    }

    // Take photo
    async function takePhoto() {
      const video = document.getElementById('viewfinder');
      const videoTrack = currentStream.getVideoTracks()[0];
      
      // Check if HDR is enabled
      if (isHDR) {
        isProcessingHDR = true;
        updateHDRStatus('Capturing HDR...');
        
        try {
          photoBlob = await processHDR(video, videoTrack);
          addToRecents(photoBlob);
          updateHDRStatus('');
        } catch (err) {
          console.error('HDR processing failed:', err);
          updateHDRStatus('HDR Failed');
          setTimeout(() => updateHDRStatus(''), 2000);
        } finally {
          isProcessingHDR = false;
        }
        return;
      }
      
      // Regular photo capture
      // Always use the full video resolution
      const videoW = video.videoWidth;
      const videoH = video.videoHeight;
      let outW = videoW;
      let outH = videoH;
      
      // Check if in landscape mode - if so, invert the aspect ratios
      const isLandscapeMode = document.body.classList.contains('landscape-mode');
      let currentAspectRatio = aspectRatio;
      
      // For landscape mode, we invert the aspect ratios (except for 1:1 which stays the same)
      if (isLandscapeMode) {
        if (currentAspectRatio === '3:4') currentAspectRatio = '4:3';
        else if (currentAspectRatio === '9:16') currentAspectRatio = '16:9';
      }
      
      // Adjust for aspect ratio selection
      if (currentAspectRatio === '1:1') {
        const minDim = Math.min(videoW, videoH);
        outW = outH = minDim;
      } else if (currentAspectRatio === '9:16') {
        if (videoW / videoH > 9/16) {
          outH = videoH;
          outW = Math.round(videoH * 9 / 16);
        } else {
          outW = videoW;
          outH = Math.round(videoW * 16 / 9);
        }
      } else if (currentAspectRatio === '16:9') {
        if (videoW / videoH > 16/9) {
          outH = videoH;
          outW = Math.round(videoH * 16 / 9);
        } else {
          outW = videoW;
          outH = Math.round(videoW * 9 / 16);
        }
      } else if (currentAspectRatio === '3:4') {
        if (videoW / videoH > 3/4) {
          outH = videoH;
          outW = Math.round(videoH * 3 / 4);
        } else {
          outW = videoW;
          outH = Math.round(videoW * 4 / 3);
        }
      } else if (currentAspectRatio === '4:3') {
        if (videoW / videoH > 4/3) {
          outH = videoH;
          outW = Math.round(videoH * 4 / 3);
        } else {
          outW = videoW;
          outH = Math.round(videoW * 3 / 4);
        }
      } // else 'full' uses full videoW/videoH
      
      const canvas = document.createElement('canvas');
      canvas.width = outW;
      canvas.height = outH;
      const ctx = canvas.getContext('2d');
      
      // Calculate cropping for aspect ratio
      let sx = 0, sy = 0, sw = videoW, sh = videoH;
      if (currentAspectRatio === '1:1') {
        if (videoW > videoH) {
          sx = Math.floor((videoW - videoH) / 2);
          sw = sh = videoH;
        } else {
          sy = Math.floor((videoH - videoW) / 2);
          sw = sh = videoW;
        }
      } else if (currentAspectRatio === '9:16') {
        if (videoW / videoH > 9/16) {
          sx = Math.floor((videoW - videoH * 9 / 16) / 2);
          sw = Math.floor(videoH * 9 / 16);
        } else {
          sy = Math.floor((videoH - videoW * 16 / 9) / 2);
          sh = Math.floor(videoW * 16 / 9);
        }
      } else if (currentAspectRatio === '16:9') {
        if (videoW / videoH > 16/9) {
          sx = Math.floor((videoW - videoH * 16 / 9) / 2);
          sw = Math.floor(videoH * 16 / 9);
        } else {
          sy = Math.floor((videoH - videoW * 9 / 16) / 2);
          sh = Math.floor(videoW * 9 / 16);
        }
      } else if (currentAspectRatio === '3:4') {
        if (videoW / videoH > 3/4) {
          sx = Math.floor((videoW - videoH * 3 / 4) / 2);
          sw = Math.floor(videoH * 3 / 4);
        } else {
          sy = Math.floor((videoH - videoW * 4 / 3) / 2);
          sh = Math.floor(videoW * 4 / 3);
        }
      } else if (currentAspectRatio === '4:3') {
        if (videoW / videoH > 4/3) {
          sx = Math.floor((videoW - videoH * 4 / 3) / 2);
          sw = Math.floor(videoH * 4 / 3);
        } else {
          sy = Math.floor((videoH - videoW * 3 / 4) / 2);
          sh = Math.floor(videoW * 3 / 4);
        }
      }
      
      // Digital zoom cropping
      if (isDigitalZoom && currentZoom !== 1) {
        const scale = currentZoom;
        const zoomedW = sw / scale;
        const zoomedH = sh / scale;
        sx += (sw - zoomedW) / 2;
        sy += (sh - zoomedH) / 2;
        sw = zoomedW;
        sh = zoomedH;
      }
      
      // Mirrored: flip canvas horizontally if needed
      let mirrored = false;
      const deviceId = currentDeviceId;
      cameraSettings = JSON.parse(localStorage.getItem('cameraSettings') || '{}');
      if (cameraSettings[deviceId] && cameraSettings[deviceId].mirrored) mirrored = true;
      
      if (mirrored) {
        ctx.save();
        ctx.translate(outW, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(video, sx, sy, sw, sh, 0, 0, outW, outH);
        ctx.restore();
      } else {
        ctx.drawImage(video, sx, sy, sw, sh, 0, 0, outW, outH);
      }
      
      // Apply night mode processing if enabled
      if (isNightMode) {
        // Get image data for processing
        const imageData = ctx.getImageData(0, 0, outW, outH);
        const data = imageData.data;
        
        // Night mode processing parameters
        const brightness = 1.2;      // Increase brightness
        const contrast = 1.3;        // Increase contrast
        const denoiseRadius = 1;     // Denoising radius
        const sigmaSpatial = 2;      // Spatial sigma for bilateral filter
        const sigmaColor = 20;       // Color sigma for bilateral filter
        const enhanceDetails = 0.8;  // Reduced detail enhancement
        
        for (let y = 0; y < outH; y++) {
            for (let x = 0; x < outW; x++) {
                const i = (y * outW + x) * 4;
                
                // Bilateral filter denoising
                let r = 0, g = 0, b = 0;
                let weightSum = 0;
                
                for (let dy = -denoiseRadius; dy <= denoiseRadius; dy++) {
                    for (let dx = -denoiseRadius; dx <= denoiseRadius; dx++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < outW && ny >= 0 && ny < outH) {
                            const ni = (ny * outW + nx) * 4;
                            const spatialDist = Math.sqrt(dx*dx + dy*dy);
                            const colorDistR = data[i] - data[ni];
                            const colorDistG = data[i+1] - data[ni+1];
                            const colorDistB = data[i+2] - data[ni+2];
                            const colorDist = Math.sqrt(colorDistR*colorDistR + colorDistG*colorDistG + colorDistB*colorDistB);
                            const weight = Math.exp( - (spatialDist*spatialDist) / (2*sigmaSpatial*sigmaSpatial) - (colorDist*colorDist) / (2*sigmaColor*sigmaColor) );
                            r += data[ni] * weight;
                            g += data[ni+1] * weight;
                            b += data[ni+2] * weight;
                            weightSum += weight;
                        }
                    }
                }
                
                if (weightSum > 0) {
                    data[i] = r / weightSum;
                    data[i+1] = g / weightSum;
                    data[i+2] = b / weightSum;
                }
                
                // Apply brightness and contrast adjustments
                for (let c = 0; c < 3; c++) {
                    let val = data[i + c];
                    val = (val - 128) * contrast + 128;  // Contrast
                    val = val * brightness;              // Brightness
                    data[i + c] = Math.max(0, Math.min(255, val));
                }
                
                // Detail enhancement (reduced strength)
                if (enhanceDetails > 1) {
                    for (let c = 0; c < 3; c++) {
                        const curr = data[i + c];
                        const top = data[i - outW * 4 + c];
                        const bottom = data[i + outW * 4 + c];
                        const left = data[i - 4 + c];
                        const right = data[i + 4 + c];
                        const edge = Math.abs(curr - top) + Math.abs(curr - bottom) + Math.abs(curr - left) + Math.abs(curr - right);
                        if (edge > 10) {  // Lower threshold
                            data[i + c] = Math.max(0, Math.min(255, curr + (edge * (enhanceDetails - 1) / 4)));
                        }
                    }
                }
            }
        }
        ctx.putImageData(imageData, 0, 0);
      }
      
      canvas.toBlob(blob => {
        photoBlob = blob;
        addToRecents(blob);
      }, 'image/jpeg', 1.0); // Max quality
    }

    // Timer logic
    document.getElementById('timer-btn').addEventListener('click', () => {
      timer = timer === 1 ? 3 : timer === 3 ? 5 : 1;
      document.getElementById('timer-btn').textContent = timer + 's';
    });

    // Shutter button
    document.getElementById('shutter-btn').addEventListener('click', async () => {
      if (isProcessingHDR) return;
      
      document.getElementById('shutter-btn').disabled = true;
      setTimeout(async () => {
        await takePhoto();
        document.getElementById('shutter-btn').disabled = false;
      }, timer * 1000);
    });

    // Switch camera button
    document.getElementById('switch-cam-btn').addEventListener('click', async () => {
      await switchCamera();
    });

    // On app start, load settings and apply to camera
    window.onload = async () => {
      await getCameras();
      if (devices.length > 0) {
        currentDeviceId = devices[0].deviceId;
        await startCamera(currentDeviceId);
      } else {
        await startCamera();
      }
      
      // Set initial aspect ratio based on active button
      const activeAspectBtn = document.querySelector('#aspect-ratio-row .settings-btn.active');
      if (activeAspectBtn) {
        aspectRatio = activeAspectBtn.dataset.aspect;
      }
      
      // Ensure zoom is reset to 1x on startup
      currentZoom = 1;
      updateViewfinderTransform();
      
      // Apply aspect ratio
      updateAspectRatio();
    };

    // Function to add a photo to recents
    function addToRecents(blob) {
      const url = URL.createObjectURL(blob);
      recentPhotos.unshift({
        url: url,
        blob: blob,
        timestamp: Date.now()
      });
      // Keep only last 20 photos
      if (recentPhotos.length > 20) {
        URL.revokeObjectURL(recentPhotos.pop().url);
      }
      // Update thumbnail
      document.getElementById('thumb').src = url;
    }

    // Function to show recents modal
    function showRecents() {
      const modal = document.getElementById('recents-modal');
      const grid = document.getElementById('recents-grid');
      
      // Pause the camera
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.enabled = false);
      }
      
      // Clear and populate grid
      grid.innerHTML = '';
      recentPhotos.forEach((photo, index) => {
        const div = document.createElement('div');
        div.className = 'recent-photo';
        div.innerHTML = `<img src="${photo.url}" alt="Recent photo">`;
        div.onclick = () => selectPhoto(div, index);
        grid.appendChild(div);
      });
      
      modal.classList.add('active');
    }

    // Function to hide recents modal
    function hideRecents() {
      const modal = document.getElementById('recents-modal');
      modal.classList.remove('active');
      
      // Resume the camera
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.enabled = true);
      }
      
      // Clear selection
      selectedPhoto = null;
      document.getElementById('save-btn').disabled = true;
    }

    // Function to select a photo
    function selectPhoto(element, index) {
      // Remove previous selection
      document.querySelectorAll('.recent-photo').forEach(photo => {
        photo.classList.remove('selected');
      });
      
      // Add new selection
      element.classList.add('selected');
      selectedPhoto = recentPhotos[index];
      document.getElementById('save-btn').disabled = false;
      
      // Show full-screen view
      showFullScreenPhoto(selectedPhoto.url);
    }

    // Function to save selected photo
    function saveSelectedPhoto() {
      if (!selectedPhoto) return;
      
      const a = document.createElement('a');
      a.href = selectedPhoto.url;
      a.download = `photo_${selectedPhoto.timestamp}.jpg`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    // Function to show full-screen photo
    function showFullScreenPhoto(url) {
      const photoView = document.getElementById('photo-view');
      const photoViewImg = document.getElementById('photo-view-img');
      photoViewImg.src = url;
      photoView.classList.add('active');
    }

    // Function to hide full-screen photo
    function hideFullScreenPhoto() {
      const photoView = document.getElementById('photo-view');
      photoView.classList.remove('active');
    }

    // Add event listeners for recents functionality
    document.getElementById('thumb').addEventListener('click', showRecents);
    document.getElementById('back-btn').addEventListener('click', hideRecents);
    document.getElementById('save-btn').addEventListener('click', saveSelectedPhoto);

    // Add event listeners for photo view
    document.getElementById('photo-view-back-btn').addEventListener('click', hideFullScreenPhoto);
    document.getElementById('photo-view-save-btn').addEventListener('click', () => {
      if (selectedPhoto) {
        saveSelectedPhoto();
      }
    });

    // Settings modal logic
    const settingsModal = document.getElementById('settings-modal');
    const settingsClose = document.getElementById('settings-close');
    const menuBtn = document.querySelector('.fa-bars');

    menuBtn.addEventListener('click', () => {
      settingsModal.classList.add('active');
    });
    settingsClose.addEventListener('click', () => {
      settingsModal.classList.remove('active');
    });

    // Aspect ratio selection
    document.querySelectorAll('#aspect-ratio-row .settings-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#aspect-ratio-row .settings-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aspectRatio = btn.dataset.aspect;
        updateAspectRatio();
      });
    });
    // Timer selection
    document.querySelectorAll('#timer-row .settings-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#timer-row .settings-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        timerSetting = btn.dataset.timer;
        updateTimer();
      });
    });
    // Set initial active
    document.querySelector('#aspect-ratio-row .settings-btn[data-aspect="3:4"]').classList.add('active');
    document.querySelector('#timer-row .settings-btn[data-timer="off"]').classList.add('active');

    // Update aspect ratio for viewfinder and photo capture
    function updateAspectRatio() {
      const video = document.getElementById('viewfinder');
      const container = video.parentElement;
      let ratio;
      
      // Remove any existing crop overlay
      let existingOverlay = document.getElementById('crop-overlay');
      if (existingOverlay) {
        existingOverlay.remove();
      }
      
      // Create crop overlay
      const overlay = document.createElement('div');
      overlay.id = 'crop-overlay';
      overlay.style.position = 'absolute';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.pointerEvents = 'none';
      overlay.style.zIndex = '5';
      
      // Apply different cropping guides based on selected aspect ratio
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      
      // Reset video style to cover full container
      video.style.width = '100%';
      video.style.height = '100%';
      
      // Check if we're in landscape mode - if so, invert the aspect ratio
      const isLandscapeMode = document.body.classList.contains('landscape-mode');
      let currentAspectRatio = aspectRatio;
      
      // For landscape mode, we invert the aspect ratios (except for 1:1 which stays the same)
      if (isLandscapeMode) {
        if (currentAspectRatio === '3:4') currentAspectRatio = '4:3';
        else if (currentAspectRatio === '9:16') currentAspectRatio = '16:9';
      }
      
      let cropWidth, cropHeight, leftOffset, topOffset;
      
      switch (currentAspectRatio) {
        case '1:1':
          ratio = 1;
          
          // Create square crop
          let squareSize = Math.min(containerWidth, containerHeight);
          leftOffset = (containerWidth - squareSize) / 2;
          topOffset = (containerHeight - squareSize) / 2;
          
          // Apply the actual crop to video
          video.style.width = squareSize + 'px';
          video.style.height = squareSize + 'px';
          video.style.objectFit = 'cover';
          
          // Create overlay for dark areas
          overlay.innerHTML = `
            <div style="position:absolute; top:0; left:0; width:100%; height:${topOffset}px; background:#000;"></div>
            <div style="position:absolute; bottom:0; left:0; width:100%; height:${topOffset}px; background:#000;"></div>
            <div style="position:absolute; top:${topOffset}px; left:0; width:${leftOffset}px; height:${squareSize}px; background:#000;"></div>
            <div style="position:absolute; top:${topOffset}px; right:0; width:${leftOffset}px; height:${squareSize}px; background:#000;"></div>
          `;
          break;
          
        case '3:4':
          ratio = 3/4;
          
          // Calculate 3:4 dimensions that fit in the container (portrait)
          if (containerWidth / containerHeight > 3/4) {
            // Container is wider than 3:4
            cropHeight = containerHeight;
            cropWidth = cropHeight * (3/4);
          } else {
            // Container is taller than 3:4
            cropWidth = containerWidth;
            cropHeight = cropWidth * (4/3);
          }
          
          leftOffset = (containerWidth - cropWidth) / 2;
          topOffset = (containerHeight - cropHeight) / 2;
          
          // Apply the actual crop to video
          video.style.width = cropWidth + 'px';
          video.style.height = cropHeight + 'px';
          video.style.objectFit = 'cover';
          
          // Create overlay for dark areas
          overlay.innerHTML = `
            <div style="position:absolute; top:0; left:0; width:100%; height:${topOffset}px; background:#000;"></div>
            <div style="position:absolute; bottom:0; left:0; width:100%; height:${topOffset}px; background:#000;"></div>
            <div style="position:absolute; top:${topOffset}px; left:0; width:${leftOffset}px; height:${cropHeight}px; background:#000;"></div>
            <div style="position:absolute; top:${topOffset}px; right:0; width:${leftOffset}px; height:${cropHeight}px; background:#000;"></div>
          `;
          break;
          
        case '4:3':
          ratio = 4/3;
          
          // Calculate 4:3 dimensions that fit in the container (landscape)
          if (containerWidth / containerHeight > 4/3) {
            // Container is wider than 4:3
            cropHeight = containerHeight;
            cropWidth = cropHeight * (4/3);
          } else {
            // Container is taller than 4:3
            cropWidth = containerWidth;
            cropHeight = cropWidth * (3/4);
          }
          
          leftOffset = (containerWidth - cropWidth) / 2;
          topOffset = (containerHeight - cropHeight) / 2;
          
          // Apply the actual crop to video
          video.style.width = cropWidth + 'px';
          video.style.height = cropHeight + 'px';
          video.style.objectFit = 'cover';
          
          // Create overlay for dark areas
          overlay.innerHTML = `
            <div style="position:absolute; top:0; left:0; width:100%; height:${topOffset}px; background:#000;"></div>
            <div style="position:absolute; bottom:0; left:0; width:100%; height:${topOffset}px; background:#000;"></div>
            <div style="position:absolute; top:${topOffset}px; left:0; width:${leftOffset}px; height:${cropHeight}px; background:#000;"></div>
            <div style="position:absolute; top:${topOffset}px; right:0; width:${leftOffset}px; height:${cropHeight}px; background:#000;"></div>
          `;
          break;
          
        case '9:16':
          ratio = 9/16;
          
          // Calculate 9:16 dimensions that fit in the container (portrait)
          if (containerWidth / containerHeight > 9/16) {
            // Container is wider than 9:16
            cropHeight = containerHeight;
            cropWidth = cropHeight * (9/16);
          } else {
            // Container is taller than 9:16
            cropWidth = containerWidth;
            cropHeight = cropWidth * (16/9);
          }
          
          leftOffset = (containerWidth - cropWidth) / 2;
          topOffset = (containerHeight - cropHeight) / 2;
          
          // Apply the actual crop to video
          video.style.width = cropWidth + 'px';
          video.style.height = cropHeight + 'px';
          video.style.objectFit = 'cover';
          
          // Create overlay for dark areas
          overlay.innerHTML = `
            <div style="position:absolute; top:0; left:0; width:100%; height:${topOffset}px; background:#000;"></div>
            <div style="position:absolute; bottom:0; left:0; width:100%; height:${topOffset}px; background:#000;"></div>
            <div style="position:absolute; top:${topOffset}px; left:0; width:${leftOffset}px; height:${cropHeight}px; background:#000;"></div>
            <div style="position:absolute; top:${topOffset}px; right:0; width:${leftOffset}px; height:${cropHeight}px; background:#000;"></div>
          `;
          break;
          
        case '16:9':
          ratio = 16/9;
          
          // Calculate 16:9 dimensions that fit in the container (landscape)
          if (containerWidth / containerHeight > 16/9) {
            // Container is wider than 16:9
            cropHeight = containerHeight;
            cropWidth = cropHeight * (16/9);
          } else {
            // Container is taller than 16:9
            cropWidth = containerWidth;
            cropHeight = cropWidth * (9/16);
          }
          
          leftOffset = (containerWidth - cropWidth) / 2;
          topOffset = (containerHeight - cropHeight) / 2;
          
          // Apply the actual crop to video
          video.style.width = cropWidth + 'px';
          video.style.height = cropHeight + 'px';
          video.style.objectFit = 'cover';
          
          // Create overlay for dark areas
          overlay.innerHTML = `
            <div style="position:absolute; top:0; left:0; width:100%; height:${topOffset}px; background:#000;"></div>
            <div style="position:absolute; bottom:0; left:0; width:100%; height:${topOffset}px; background:#000;"></div>
            <div style="position:absolute; top:${topOffset}px; left:0; width:${leftOffset}px; height:${cropHeight}px; background:#000;"></div>
            <div style="position:absolute; top:${topOffset}px; right:0; width:${leftOffset}px; height:${cropHeight}px; background:#000;"></div>
          `;
          break;
          
        default: // 'full'
          // Reset to full container
          video.style.width = '100%';
          video.style.height = '100%';
          video.style.objectFit = 'cover';
          break;
      }
      
      // Add overlay to container if not 'full'
      if (currentAspectRatio !== 'full') {
        container.appendChild(overlay);
        
        // Center the video element within the container
        video.style.position = 'absolute';
        video.style.left = '50%';
        video.style.top = '50%';
        video.style.transform = 'translate(-50%, -50%)';
      } else {
        // Reset video position for full view
        video.style.position = 'absolute';
        video.style.top = '50%';
        video.style.left = '50%';
        video.style.transform = 'translate(-50%, -50%)';
      }
      
      // Update transform to maintain mirroring and zoom if present
      updateViewfinderTransform();
    }
    
    // Add window resize handler to update aspect ratio
    window.addEventListener('resize', () => {
      updateAspectRatio();
    });

    // Show resolution in UI
    function showResolution(w, h) {
      let resDiv = document.getElementById('camera-resolution');
      if (!resDiv) {
        resDiv = document.createElement('div');
        resDiv.id = 'camera-resolution';
        resDiv.style.position = 'absolute';
        resDiv.style.bottom = '8px';
        resDiv.style.right = '16px';
        resDiv.style.background = '#000';
        resDiv.style.color = '#fff';
        resDiv.style.fontSize = '1rem';
        resDiv.style.padding = '4px 10px';
        resDiv.style.borderRadius = '8px';
        resDiv.style.zIndex = '100';
        document.querySelector('.viewfinder-container').appendChild(resDiv);
      }
      if (w && h) {
        const mp = (w * h / 1e6).toFixed(1);
        resDiv.textContent = `${w} x ${h} (${mp} MP)`;
      } else {
        resDiv.textContent = '';
      }
    }

    // Device Camera Settings Modal Logic
    const deviceSettingsModal = document.getElementById('device-settings-modal');
    const deviceSettingsClose = document.getElementById('device-settings-close');
    const deviceSettingsSave = document.getElementById('device-settings-save');
    const deviceSettingsList = document.getElementById('device-settings-list');
    const settingsIconBtn = document.querySelector('.settings-icon-btn:last-child');

    let cameraSettings = {};

    // Open device settings modal from settings modal
    settingsIconBtn.addEventListener('click', () => {
      settingsModal.classList.remove('active');
      openDeviceSettingsModal();
    });
    deviceSettingsClose.addEventListener('click', () => {
      deviceSettingsModal.classList.remove('active');
      settingsModal.classList.add('active');
    });

    function openDeviceSettingsModal() {
      enumerateCamerasAndBuildUI();
      deviceSettingsModal.classList.add('active');
    }

    // Enumerate cameras and build UI
    async function enumerateCamerasAndBuildUI() {
      const devices = (await navigator.mediaDevices.enumerateDevices()).filter(d => d.kind === 'videoinput');
      // Load saved settings
      cameraSettings = JSON.parse(localStorage.getItem('cameraSettings') || '{}');
      deviceSettingsList.innerHTML = '';
      for (const device of devices) {
        // Try to get supported resolutions
        let resolutions = [{label:'Default', value:''}];
        try {
          const stream = await navigator.mediaDevices.getUserMedia({video: {deviceId: {exact: device.deviceId}}});
          const track = stream.getVideoTracks()[0];
          const caps = track.getCapabilities();
          if (caps.width && caps.height) {
            // Build a list of common resolutions within supported range
            const wmin = caps.width.min, wmax = caps.width.max;
            const hmin = caps.height.min, hmax = caps.height.max;
            const common = [
              [1920,1080],[1280,720],[640,480],[3840,2160],[2560,1440],[1600,1200],[1024,768],[800,600],[320,240]
            ];
            for (const [w,h] of common) {
              if (w >= wmin && w <= wmax && h >= hmin && h <= hmax) {
                resolutions.push({label:`${w}x${h}`, value:`${w}x${h}`});
              }
            }
            // Add max
            if (!resolutions.find(r => r.value === `${wmax}x${hmax}`)) {
              resolutions.unshift({label:`Max (${wmax}x${hmax})`, value:`${wmax}x${hmax}`});
            }
          }
          track.stop();
        } catch (e) {}
        // Get saved settings or defaults
        const saved = cameraSettings[device.deviceId] || {};
        // Build UI
        const div = document.createElement('div');
        div.className = 'device-settings-item';
        div.innerHTML = `
          <div class="device-settings-row">
            <label>Name</label>
            <input type="text" value="${saved.name || device.label || 'Camera'}" data-key="name">
          </div>
          <div class="device-settings-row">
            <label>Resolution</label>
            <select data-key="resolution">
              ${resolutions.map(r => `<option value="${r.value}"${saved.resolution===r.value?' selected':''}>${r.label}</option>`).join('')}
            </select>
          </div>
          <div class="device-settings-row">
            <label>Mirrored</label>
            <input type="checkbox" data-key="mirrored"${saved.mirrored?' checked':''}>
          </div>
          <div class="device-settings-row">
            <label>Mode</label>
            <select data-key="mode">
              <option value="">Default</option>
              <option value="user"${saved.mode==='user'?' selected':''}>User</option>
              <option value="environment"${saved.mode==='environment'?' selected':''}>Environment</option>
            </select>
          </div>
        `;
        // Store deviceId for saving
        div.dataset.deviceId = device.deviceId;
        deviceSettingsList.appendChild(div);
      }
    }

    // Save device settings
    deviceSettingsSave.addEventListener('click', () => {
      // Gather all settings
      const items = deviceSettingsList.querySelectorAll('.device-settings-item');
      for (const item of items) {
        const deviceId = item.dataset.deviceId;
        const name = item.querySelector('input[data-key="name"]').value;
        const resolution = item.querySelector('select[data-key="resolution"]').value;
        const mirrored = item.querySelector('input[data-key="mirrored"]').checked;
        const mode = item.querySelector('select[data-key="mode"]').value;
        cameraSettings[deviceId] = { name, resolution, mirrored, mode };
      }
      localStorage.setItem('cameraSettings', JSON.stringify(cameraSettings));
      deviceSettingsModal.classList.remove('active');
      settingsModal.classList.add('active');
    });

    // Show supported features in UI
    function showSupportedFeatures(features) {
      let featDiv = document.getElementById('camera-features');
      if (!featDiv) {
        featDiv = document.createElement('div');
        featDiv.id = 'camera-features';
        featDiv.style.position = 'absolute';
        featDiv.style.bottom = '40px';
        featDiv.style.right = '16px';
        featDiv.style.background = '#000';
        featDiv.style.color = '#fff';
        featDiv.style.fontSize = '0.95rem';
        featDiv.style.padding = '3px 10px';
        featDiv.style.borderRadius = '8px';
        featDiv.style.zIndex = '100';
        document.querySelector('.viewfinder-container').appendChild(featDiv);
      }
      featDiv.textContent = features.length ? 'Features: ' + features.join(', ') : '';
    }

    // Add HDR status indicator
    function updateHDRStatus(status) {
      let statusDiv = document.getElementById('hdr-status');
      if (!statusDiv) {
        statusDiv = document.createElement('div');
        statusDiv.id = 'hdr-status';
        statusDiv.style.position = 'absolute';
        statusDiv.style.top = '50%';
        statusDiv.style.left = '50%';
        statusDiv.style.transform = 'translate(-50%, -50%)';
        statusDiv.style.background = '#000';
        statusDiv.style.color = '#fff';
        statusDiv.style.padding = '12px 24px';
        statusDiv.style.borderRadius = '8px';
        statusDiv.style.fontSize = '1.2rem';
        statusDiv.style.zIndex = '1000';
        document.querySelector('.viewfinder-container').appendChild(statusDiv);
      }
      statusDiv.textContent = status;
      statusDiv.style.display = status ? 'block' : 'none';
    }

    // Modify HDR button click handler
    document.querySelector('.settings-icon-btn:first-child').addEventListener('click', function() {
      this.classList.toggle('active');
      isHDR = this.classList.contains('active');
      if (isHDR) {
        updateHDRStatus('HDR Enabled');
        setTimeout(() => updateHDRStatus(''), 2000);
      }
    });

    // Timer selection
    function updateTimer() {
      if (timerSetting === 'off') {
        timer = 0;
      } else {
        timer = parseInt(timerSetting, 10);
      }
    }
    
             // Handle device orientation changes
    function handleOrientationChange() {
      // Detect landscape mode using both matchMedia and window dimensions
      const isMediaLandscape = window.matchMedia("(orientation: landscape)").matches;
      const isDimensionsLandscape = window.innerWidth > window.innerHeight;
      const isLandscapeNow = isMediaLandscape || isDimensionsLandscape;
      
      if (isLandscapeNow !== isLandscape) {
        isLandscape = isLandscapeNow;
        
        if (isLandscape) {
          document.body.classList.add('landscape-mode');
          console.log('Entered landscape mode');
        } else {
          document.body.classList.remove('landscape-mode');
          console.log('Exited landscape mode');
        }
        
        // Update aspect ratio to maintain proper crop in new orientation
        setTimeout(() => {
          updateAspectRatio();
        }, 300); // Short delay to let the UI update first
      }
    }
    
    // Add rotate-item class to elements that need to rotate in landscape mode
    function setupRotatableElements() {
      // Top bar icons
      document.querySelectorAll('.top-bar i').forEach(icon => {
        icon.classList.add('rotate-item');
      });
      
      // Mode switcher text
      document.querySelectorAll('.mode-switcher span').forEach(span => {
        span.classList.add('rotate-item');
      });
      
      // Bottom controls icons
      document.querySelector('.switch-cam-btn i').classList.add('rotate-item');
      
      // Side buttons icons
      document.querySelectorAll('.side-btns button i').forEach(icon => {
        icon.classList.add('rotate-item');
      });
      
      // Timer button
      document.getElementById('timer-btn').classList.add('rotate-item');
      
      // Zoom bar text
      document.querySelectorAll('.zoom-bar span').forEach(span => {
        span.classList.add('rotate-item');
      });
      
      // Do not rotate viewfinder text
      // document.querySelector('.viewfinder-text').classList.add('rotate-item');
    }
    
    // Listen for orientation changes
    window.addEventListener('orientationchange', handleOrientationChange);
    window.addEventListener('resize', handleOrientationChange);
    
    // Initial setup
    document.addEventListener('DOMContentLoaded', () => {
      setupRotatableElements();
      handleOrientationChange();
    });

    // Flash toggle
    const flashBtn = document.getElementById('flash-btn');
    flashBtn.addEventListener('click', async () => {
      if (!currentStream) return;
      const track = currentStream.getVideoTracks()[0];
      const capabilities = track.getCapabilities();
      if (capabilities.torch) {
        const settings = track.getSettings();
        try {
          await track.applyConstraints({
            advanced: [{ torch: !settings.torch }]
          });
          const newSettings = track.getSettings();
          flashBtn.classList.toggle('active', newSettings.torch);
        } catch (err) {
          alert('Failed to toggle flash: ' + err.message);
        }
      } else {
        alert('Flash is not supported on this device');
      }
    });
    
    // Night mode toggle
    const nightModeBtn = document.getElementById('night-mode-btn');
    const nightModeIndicator = document.querySelector('.night-mode-indicator');
    
    nightModeBtn.addEventListener('click', () => {
      isNightMode = !isNightMode;
      nightModeBtn.classList.toggle('active', isNightMode);
      nightModeIndicator.classList.toggle('active', isNightMode);
    });
  </script>
</body>
</html>
